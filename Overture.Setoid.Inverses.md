---
layout: default
title : "Overture.Setoid.Inverses module"
date : "2021-09-10"
author: "the agda-algebras development team"
---

### <a id="inverses-for-functions-on-setoids">Inverses for functions on setoids</a>

This is the [Overture.Setoid.Inverses][] module of the [agda-algebras][] library.
<pre class="Agda">

<a id="314" class="Symbol">{-#</a> <a id="318" class="Keyword">OPTIONS</a> <a id="326" class="Pragma">--without-K</a> <a id="338" class="Pragma">--exact-split</a> <a id="352" class="Pragma">--safe</a> <a id="359" class="Symbol">#-}</a>

<a id="364" class="Keyword">open</a> <a id="369" class="Keyword">import</a> <a id="376" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="392" class="Keyword">using</a> <a id="398" class="Symbol">(</a> <a id="400" href="Relation.Binary.Bundles.html#1009" class="Record">Setoid</a> <a id="407" class="Symbol">)</a>

<a id="410" class="Keyword">module</a> <a id="417" href="Overture.Setoid.Inverses.html" class="Module">Overture.Setoid.Inverses</a>
 <a id="443" class="Symbol">{</a><a id="444" href="Overture.Setoid.Inverses.html#444" class="Bound">α</a> <a id="446" href="Overture.Setoid.Inverses.html#446" class="Bound">ρᵃ</a> <a id="449" href="Overture.Setoid.Inverses.html#449" class="Bound">β</a> <a id="451" href="Overture.Setoid.Inverses.html#451" class="Bound">ρᵇ</a><a id="453" class="Symbol">}{</a><a id="455" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="457" class="Symbol">:</a> <a id="459" href="Relation.Binary.Bundles.html#1009" class="Record">Setoid</a> <a id="466" href="Overture.Setoid.Inverses.html#444" class="Bound">α</a> <a id="468" href="Overture.Setoid.Inverses.html#446" class="Bound">ρᵃ</a><a id="470" class="Symbol">}{</a><a id="472" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a> <a id="474" class="Symbol">:</a> <a id="476" href="Relation.Binary.Bundles.html#1009" class="Record">Setoid</a> <a id="483" href="Overture.Setoid.Inverses.html#449" class="Bound">β</a> <a id="485" href="Overture.Setoid.Inverses.html#451" class="Bound">ρᵇ</a><a id="487" class="Symbol">}</a> <a id="489" class="Keyword">where</a>

<a id="496" class="Comment">-- Imports from Agda and the Agda Standard Library --------------------</a>
<a id="568" class="Keyword">open</a> <a id="573" class="Keyword">import</a> <a id="580" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>    <a id="598" class="Keyword">using</a> <a id="604" class="Symbol">(</a> <a id="606" href="Agda.Primitive.html#810" class="Primitive Operator">_⊔_</a> <a id="610" class="Symbol">)</a> <a id="612" class="Keyword">renaming</a> <a id="621" class="Symbol">(</a> <a id="623" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="627" class="Symbol">to</a> <a id="630" class="Primitive">Type</a> <a id="635" class="Symbol">)</a>
<a id="637" class="Keyword">open</a> <a id="642" class="Keyword">import</a> <a id="649" href="Function.Equality.html" class="Module">Function.Equality</a> <a id="667" class="Keyword">using</a> <a id="673" class="Symbol">(</a> <a id="675" href="Function.Equality.html#889" class="Record">Π</a> <a id="677" class="Symbol">;</a> <a id="679" href="Function.Equality.html#1218" class="Function Operator">_⟶_</a> <a id="683" class="Symbol">)</a>
<a id="685" class="Keyword">import</a>      <a id="697" href="Function.Definitions.html" class="Module">Function.Definitions</a> <a id="718" class="Symbol">as</a> <a id="721" class="Module">FunctionDefinitions</a>
<a id="741" class="Keyword">import</a>      <a id="753" href="Function.Structures.html" class="Module">Function.Structures</a> <a id="773" class="Symbol">as</a> <a id="776" class="Module">FunctionStructures</a>
<a id="795" class="Keyword">open</a> <a id="800" class="Keyword">import</a> <a id="807" href="Data.Product.html" class="Module">Data.Product</a>      <a id="825" class="Keyword">using</a> <a id="831" class="Symbol">(</a> <a id="833" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="837" class="Symbol">)</a>
<a id="839" class="Keyword">open</a> <a id="844" class="Keyword">import</a> <a id="851" href="Relation.Unary.html" class="Module">Relation.Unary</a>    <a id="869" class="Keyword">using</a> <a id="875" class="Symbol">(</a> <a id="877" href="Relation.Unary.html#1101" class="Function">Pred</a> <a id="882" class="Symbol">;</a> <a id="884" href="Relation.Unary.html#1523" class="Function Operator">_∈_</a> <a id="888" class="Symbol">)</a>

<a id="891" class="Comment">-- Imports from agda-algebras -----------------------------------------</a>
<a id="963" class="Keyword">open</a> <a id="968" class="Keyword">import</a> <a id="975" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="998" class="Keyword">using</a> <a id="1004" class="Symbol">(</a><a id="1005" href="Overture.Preliminaries.html#5626" class="Function">∃-syntax</a><a id="1013" class="Symbol">)</a>

<a id="1016" class="Keyword">open</a> <a id="1021" href="Relation.Binary.Bundles.html#1009" class="Module">Setoid</a> <a id="1028" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="1030" class="Keyword">using</a> <a id="1036" class="Symbol">()</a> <a id="1039" class="Keyword">renaming</a> <a id="1048" class="Symbol">(</a><a id="1049" href="Relation.Binary.Bundles.html#1072" class="Field">Carrier</a> <a id="1057" class="Symbol">to</a> <a id="1060" class="Field">A</a><a id="1061" class="Symbol">;</a> <a id="1063" href="Relation.Binary.Bundles.html#1098" class="Field Operator">_≈_</a> <a id="1067" class="Symbol">to</a> <a id="1070" class="Field Operator">_≈₁_</a><a id="1074" class="Symbol">)</a>
<a id="1076" class="Keyword">open</a> <a id="1081" href="Relation.Binary.Bundles.html#1009" class="Module">Setoid</a> <a id="1088" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a> <a id="1090" class="Keyword">using</a> <a id="1096" class="Symbol">(</a> <a id="1098" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="1102" class="Symbol">)</a> <a id="1104" class="Keyword">renaming</a> <a id="1113" class="Symbol">(</a><a id="1114" href="Relation.Binary.Bundles.html#1072" class="Field">Carrier</a> <a id="1122" class="Symbol">to</a> <a id="1125" class="Field">B</a><a id="1126" class="Symbol">;</a> <a id="1128" href="Relation.Binary.Bundles.html#1098" class="Field Operator">_≈_</a> <a id="1132" class="Symbol">to</a> <a id="1135" class="Field Operator">_≈₂_</a><a id="1139" class="Symbol">)</a>
<a id="1141" class="Keyword">open</a> <a id="1146" href="Function.Definitions.html" class="Module">FunctionDefinitions</a> <a id="1166" href="Overture.Setoid.Inverses.html#1070" class="Function Operator">_≈₁_</a> <a id="1171" href="Overture.Setoid.Inverses.html#1135" class="Field Operator">_≈₂_</a>
<a id="1176" class="Keyword">open</a> <a id="1181" href="Function.Structures.html" class="Module">FunctionStructures</a>  <a id="1201" href="Overture.Setoid.Inverses.html#1070" class="Function Operator">_≈₁_</a> <a id="1206" href="Overture.Setoid.Inverses.html#1135" class="Field Operator">_≈₂_</a>

</pre>

We begin by defining an data type that represents the semantic concept of *inverse image* of a function.

<pre class="Agda">

<a id="1344" class="Keyword">open</a> <a id="1349" href="Function.Equality.html#889" class="Module">Π</a>

<a id="1352" class="Keyword">data</a> <a id="Image_∋_"></a><a id="1357" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image_∋_</a> <a id="1366" class="Symbol">(</a><a id="1367" href="Overture.Setoid.Inverses.html#1367" class="Bound">f</a> <a id="1369" class="Symbol">:</a> <a id="1371" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="1373" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="1375" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="1376" class="Symbol">)</a> <a id="1378" class="Symbol">:</a> <a id="1380" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a> <a id="1382" class="Symbol">→</a> <a id="1384" href="Overture.Setoid.Inverses.html#630" class="Primitive">Type</a> <a id="1389" class="Symbol">(</a><a id="1390" href="Overture.Setoid.Inverses.html#444" class="Bound">α</a> <a id="1392" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1394" href="Overture.Setoid.Inverses.html#449" class="Bound">β</a> <a id="1396" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1398" href="Overture.Setoid.Inverses.html#451" class="Bound">ρᵇ</a><a id="1400" class="Symbol">)</a> <a id="1402" class="Keyword">where</a>
 <a id="Image_∋_.eq"></a><a id="1409" href="Overture.Setoid.Inverses.html#1409" class="InductiveConstructor">eq</a> <a id="1412" class="Symbol">:</a> <a id="1414" class="Symbol">{</a><a id="1415" href="Overture.Setoid.Inverses.html#1415" class="Bound">b</a> <a id="1417" class="Symbol">:</a> <a id="1419" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a><a id="1420" class="Symbol">}</a> <a id="1422" class="Symbol">→</a> <a id="1424" class="Symbol">(</a><a id="1425" href="Overture.Setoid.Inverses.html#1425" class="Bound">a</a> <a id="1427" class="Symbol">:</a> <a id="1429" href="Overture.Setoid.Inverses.html#1060" class="Function">A</a><a id="1430" class="Symbol">)</a> <a id="1432" class="Symbol">→</a> <a id="1434" href="Overture.Setoid.Inverses.html#1415" class="Bound">b</a> <a id="1436" href="Overture.Setoid.Inverses.html#1135" class="Field Operator">≈₂</a> <a id="1439" class="Symbol">(</a><a id="1440" href="Overture.Setoid.Inverses.html#1367" class="Bound">f</a> <a id="1442" href="Function.Equality.html#1064" class="Field Operator">⟨$⟩</a> <a id="1446" href="Overture.Setoid.Inverses.html#1425" class="Bound">a</a><a id="1447" class="Symbol">)</a> <a id="1449" class="Symbol">→</a> <a id="1451" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image</a> <a id="1457" href="Overture.Setoid.Inverses.html#1367" class="Bound">f</a> <a id="1459" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">∋</a> <a id="1461" href="Overture.Setoid.Inverses.html#1415" class="Bound">b</a>

<a id="1464" class="Keyword">open</a> <a id="1469" href="Overture.Setoid.Inverses.html#1357" class="Module Operator">Image_∋_</a>

<a id="Range"></a><a id="1479" href="Overture.Setoid.Inverses.html#1479" class="Function">Range</a> <a id="1485" class="Symbol">:</a> <a id="1487" class="Symbol">(</a><a id="1488" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="1490" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="1492" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="1493" class="Symbol">)</a> <a id="1495" class="Symbol">→</a> <a id="1497" href="Relation.Unary.html#1101" class="Function">Pred</a> <a id="1502" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a> <a id="1504" class="Symbol">(</a><a id="1505" href="Overture.Setoid.Inverses.html#444" class="Bound">α</a> <a id="1507" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1509" href="Overture.Setoid.Inverses.html#451" class="Bound">ρᵇ</a><a id="1511" class="Symbol">)</a>
<a id="1513" href="Overture.Setoid.Inverses.html#1479" class="Function">Range</a> <a id="1519" href="Overture.Setoid.Inverses.html#1519" class="Bound">f</a> <a id="1521" href="Overture.Setoid.Inverses.html#1521" class="Bound">b</a> <a id="1523" class="Symbol">=</a> <a id="1525" href="Overture.Preliminaries.html#5626" class="Function">∃[</a> <a id="1528" href="Overture.Setoid.Inverses.html#1528" class="Bound">a</a> <a id="1530" href="Overture.Preliminaries.html#5626" class="Function">∈</a> <a id="1532" href="Overture.Preliminaries.html#5626" class="Function">A</a> <a id="1534" href="Overture.Preliminaries.html#5626" class="Function">]</a> <a id="1536" class="Symbol">(</a><a id="1537" href="Overture.Setoid.Inverses.html#1519" class="Bound">f</a> <a id="1539" href="Function.Equality.html#1064" class="Field Operator">⟨$⟩</a> <a id="1543" href="Overture.Setoid.Inverses.html#1528" class="Bound">a</a><a id="1544" class="Symbol">)</a> <a id="1546" href="Overture.Setoid.Inverses.html#1135" class="Field Operator">≈₂</a> <a id="1549" href="Overture.Setoid.Inverses.html#1521" class="Bound">b</a>

<a id="Image⊆Range"></a><a id="1552" href="Overture.Setoid.Inverses.html#1552" class="Function">Image⊆Range</a> <a id="1564" class="Symbol">:</a> <a id="1566" class="Symbol">(</a><a id="1567" href="Overture.Setoid.Inverses.html#1567" class="Bound">f</a> <a id="1569" class="Symbol">:</a> <a id="1571" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="1573" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="1575" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="1576" class="Symbol">)</a> <a id="1578" class="Symbol">→</a> <a id="1580" class="Symbol">∀</a> <a id="1582" href="Overture.Setoid.Inverses.html#1582" class="Bound">b</a> <a id="1584" class="Symbol">→</a> <a id="1586" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image</a> <a id="1592" href="Overture.Setoid.Inverses.html#1567" class="Bound">f</a> <a id="1594" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">∋</a> <a id="1596" href="Overture.Setoid.Inverses.html#1582" class="Bound">b</a> <a id="1598" class="Symbol">→</a> <a id="1600" href="Overture.Setoid.Inverses.html#1582" class="Bound">b</a> <a id="1602" href="Relation.Unary.html#1523" class="Function Operator">∈</a> <a id="1604" href="Overture.Setoid.Inverses.html#1479" class="Function">Range</a> <a id="1610" href="Overture.Setoid.Inverses.html#1567" class="Bound">f</a>
<a id="1612" href="Overture.Setoid.Inverses.html#1552" class="Function">Image⊆Range</a> <a id="1624" href="Overture.Setoid.Inverses.html#1624" class="Bound">f</a> <a id="1626" href="Overture.Setoid.Inverses.html#1626" class="Bound">b</a> <a id="1628" class="Symbol">(</a><a id="1629" href="Overture.Setoid.Inverses.html#1409" class="InductiveConstructor">eq</a> <a id="1632" href="Overture.Setoid.Inverses.html#1632" class="Bound">a</a> <a id="1634" href="Overture.Setoid.Inverses.html#1634" class="Bound">x</a><a id="1635" class="Symbol">)</a> <a id="1637" class="Symbol">=</a> <a id="1639" href="Overture.Setoid.Inverses.html#1632" class="Bound">a</a> <a id="1641" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1643" class="Symbol">(</a><a id="1644" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="1648" href="Overture.Setoid.Inverses.html#1634" class="Bound">x</a><a id="1649" class="Symbol">)</a>

<a id="Range⊆Image"></a><a id="1652" href="Overture.Setoid.Inverses.html#1652" class="Function">Range⊆Image</a> <a id="1664" class="Symbol">:</a> <a id="1666" class="Symbol">(</a><a id="1667" href="Overture.Setoid.Inverses.html#1667" class="Bound">f</a> <a id="1669" class="Symbol">:</a> <a id="1671" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="1673" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="1675" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="1676" class="Symbol">)</a> <a id="1678" class="Symbol">→</a> <a id="1680" class="Symbol">∀</a> <a id="1682" href="Overture.Setoid.Inverses.html#1682" class="Bound">b</a> <a id="1684" class="Symbol">→</a> <a id="1686" href="Overture.Setoid.Inverses.html#1682" class="Bound">b</a> <a id="1688" href="Relation.Unary.html#1523" class="Function Operator">∈</a> <a id="1690" href="Overture.Setoid.Inverses.html#1479" class="Function">Range</a> <a id="1696" href="Overture.Setoid.Inverses.html#1667" class="Bound">f</a> <a id="1698" class="Symbol">→</a> <a id="1700" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image</a> <a id="1706" href="Overture.Setoid.Inverses.html#1667" class="Bound">f</a> <a id="1708" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">∋</a> <a id="1710" href="Overture.Setoid.Inverses.html#1682" class="Bound">b</a>
<a id="1712" href="Overture.Setoid.Inverses.html#1652" class="Function">Range⊆Image</a> <a id="1724" href="Overture.Setoid.Inverses.html#1724" class="Bound">f</a> <a id="1726" href="Overture.Setoid.Inverses.html#1726" class="Bound">b</a> <a id="1728" class="Symbol">(</a><a id="1729" href="Overture.Setoid.Inverses.html#1729" class="Bound">a</a> <a id="1731" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1733" href="Overture.Setoid.Inverses.html#1733" class="Bound">x</a><a id="1734" class="Symbol">)</a> <a id="1736" class="Symbol">=</a> <a id="1738" href="Overture.Setoid.Inverses.html#1409" class="InductiveConstructor">eq</a> <a id="1741" href="Overture.Setoid.Inverses.html#1729" class="Bound">a</a> <a id="1743" class="Symbol">(</a><a id="1744" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="1748" href="Overture.Setoid.Inverses.html#1733" class="Bound">x</a><a id="1749" class="Symbol">)</a>

</pre>

An inhabitant of `Image f ∋ b` is a dependent pair `(a , p)`, where `a : A` and `p : b ≡ f a` is a proof that `f` maps `a` to `b`.  Since the proof that `b` belongs to the image of `f` is always accompanied by a witness `a : A`, we can actually *compute* a (pseudo)inverse of `f`. For convenience, we define this inverse function, which we call `Inv`, and which takes an arbitrary `b : B` and a (*witness*, *proof*)-pair, `(a , p) : Image f ∋ b`, and returns the witness `a`.

<pre class="Agda">

<a id="Inv"></a><a id="2255" href="Overture.Setoid.Inverses.html#2255" class="Function">Inv</a> <a id="2259" class="Symbol">:</a> <a id="2261" class="Symbol">(</a><a id="2262" href="Overture.Setoid.Inverses.html#2262" class="Bound">f</a> <a id="2264" class="Symbol">:</a> <a id="2266" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="2268" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="2270" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="2271" class="Symbol">){</a><a id="2273" href="Overture.Setoid.Inverses.html#2273" class="Bound">b</a> <a id="2275" class="Symbol">:</a> <a id="2277" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a><a id="2278" class="Symbol">}</a> <a id="2280" class="Symbol">→</a> <a id="2282" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image</a> <a id="2288" href="Overture.Setoid.Inverses.html#2262" class="Bound">f</a> <a id="2290" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">∋</a> <a id="2292" href="Overture.Setoid.Inverses.html#2273" class="Bound">b</a>  <a id="2295" class="Symbol">→</a>  <a id="2298" href="Overture.Setoid.Inverses.html#1060" class="Function">A</a>
<a id="2300" href="Overture.Setoid.Inverses.html#2255" class="Function">Inv</a> <a id="2304" class="Symbol">_</a> <a id="2306" class="Symbol">(</a><a id="2307" href="Overture.Setoid.Inverses.html#1409" class="InductiveConstructor">eq</a> <a id="2310" href="Overture.Setoid.Inverses.html#2310" class="Bound">a</a> <a id="2312" class="Symbol">_)</a> <a id="2315" class="Symbol">=</a> <a id="2317" href="Overture.Setoid.Inverses.html#2310" class="Bound">a</a>

<a id="Inv&#39;"></a><a id="2320" href="Overture.Setoid.Inverses.html#2320" class="Function">Inv&#39;</a> <a id="2325" class="Symbol">:</a> <a id="2327" class="Symbol">(</a><a id="2328" href="Overture.Setoid.Inverses.html#2328" class="Bound">f</a> <a id="2330" class="Symbol">:</a> <a id="2332" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="2334" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="2336" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="2337" class="Symbol">){</a><a id="2339" href="Overture.Setoid.Inverses.html#2339" class="Bound">b</a> <a id="2341" class="Symbol">:</a> <a id="2343" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a><a id="2344" class="Symbol">}</a> <a id="2346" class="Symbol">→</a> <a id="2348" href="Overture.Setoid.Inverses.html#2339" class="Bound">b</a> <a id="2350" href="Relation.Unary.html#1523" class="Function Operator">∈</a> <a id="2352" href="Overture.Setoid.Inverses.html#1479" class="Function">Range</a> <a id="2358" href="Overture.Setoid.Inverses.html#2328" class="Bound">f</a> <a id="2360" class="Symbol">→</a> <a id="2362" href="Overture.Setoid.Inverses.html#1060" class="Function">A</a>
<a id="2364" href="Overture.Setoid.Inverses.html#2320" class="Function">Inv&#39;</a> <a id="2369" class="Symbol">_</a> <a id="2371" class="Symbol">(</a><a id="2372" href="Overture.Setoid.Inverses.html#2372" class="Bound">a</a> <a id="2374" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2376" class="Symbol">_)</a> <a id="2379" class="Symbol">=</a> <a id="2381" href="Overture.Setoid.Inverses.html#2372" class="Bound">a</a>

</pre>

We can prove that `Inv f` is the range-restricted right-inverse of `f`, as follows.

<pre class="Agda">

<a id="InvIsInv"></a><a id="2495" href="Overture.Setoid.Inverses.html#2495" class="Function">InvIsInv</a> <a id="2504" class="Symbol">:</a> <a id="2506" class="Symbol">(</a><a id="2507" href="Overture.Setoid.Inverses.html#2507" class="Bound">f</a> <a id="2509" class="Symbol">:</a> <a id="2511" href="Overture.Setoid.Inverses.html#455" class="Bound">𝑨</a> <a id="2513" href="Function.Equality.html#1218" class="Function Operator">⟶</a> <a id="2515" href="Overture.Setoid.Inverses.html#472" class="Bound">𝑩</a><a id="2516" class="Symbol">){</a><a id="2518" href="Overture.Setoid.Inverses.html#2518" class="Bound">b</a> <a id="2520" class="Symbol">:</a> <a id="2522" href="Overture.Setoid.Inverses.html#1125" class="Field">B</a><a id="2523" class="Symbol">}(</a><a id="2525" href="Overture.Setoid.Inverses.html#2525" class="Bound">q</a> <a id="2527" class="Symbol">:</a> <a id="2529" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">Image</a> <a id="2535" href="Overture.Setoid.Inverses.html#2507" class="Bound">f</a> <a id="2537" href="Overture.Setoid.Inverses.html#1357" class="Datatype Operator">∋</a> <a id="2539" href="Overture.Setoid.Inverses.html#2518" class="Bound">b</a><a id="2540" class="Symbol">)</a> <a id="2542" class="Symbol">→</a> <a id="2544" class="Symbol">(</a><a id="2545" href="Overture.Setoid.Inverses.html#2507" class="Bound">f</a> <a id="2547" href="Function.Equality.html#1064" class="Field Operator">⟨$⟩</a> <a id="2551" class="Symbol">(</a><a id="2552" href="Overture.Setoid.Inverses.html#2255" class="Function">Inv</a> <a id="2556" href="Overture.Setoid.Inverses.html#2507" class="Bound">f</a> <a id="2558" href="Overture.Setoid.Inverses.html#2525" class="Bound">q</a><a id="2559" class="Symbol">))</a> <a id="2562" href="Overture.Setoid.Inverses.html#1135" class="Field Operator">≈₂</a> <a id="2565" href="Overture.Setoid.Inverses.html#2518" class="Bound">b</a>
<a id="2567" href="Overture.Setoid.Inverses.html#2495" class="Function">InvIsInv</a> <a id="2576" href="Overture.Setoid.Inverses.html#2576" class="Bound">f</a> <a id="2578" class="Symbol">(</a><a id="2579" href="Overture.Setoid.Inverses.html#1409" class="InductiveConstructor">eq</a> <a id="2582" class="Symbol">_</a> <a id="2584" href="Overture.Setoid.Inverses.html#2584" class="Bound">p</a><a id="2585" class="Symbol">)</a> <a id="2587" class="Symbol">=</a> <a id="2589" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="2593" href="Overture.Setoid.Inverses.html#2584" class="Bound">p</a>

</pre>

Of course, the "range-restricted" qualifier is needed because `Inf f` is not defined outside the range of `f`.

--------------------------------------

<span style="float:left;">[← Overture.Setoid.Preliminaries](Overture.Setoid.Preliminaries.html)</span>
<span style="float:right;">[Overture.Setoid.Injective →](Overture.Setoid.Injective.html)</span>

{% include UALib.Links.md %}


