---
layout: default
title : Overture.Inverses module
date : 2021-01-12
author: [agda-algebras development team][]
---

### <a id="inverses">Inverses</a>

This is the [Overture.Inverses][] module of the [agda-algebras][] library.

<pre class="Agda">

<a id="245" class="Symbol">{-#</a> <a id="249" class="Keyword">OPTIONS</a> <a id="257" class="Pragma">--without-K</a> <a id="269" class="Pragma">--exact-split</a> <a id="283" class="Pragma">--safe</a> <a id="290" class="Symbol">#-}</a>


<a id="296" class="Keyword">module</a> <a id="303" href="Overture.Inverses.html" class="Module">Overture.Inverses</a> <a id="321" class="Keyword">where</a>

<a id="328" class="Comment">-- Imports from Agda and the Agda Standard Library ---------------------------------------------</a>
<a id="425" class="Keyword">open</a> <a id="430" class="Keyword">import</a> <a id="437" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>              <a id="465" class="Keyword">using</a> <a id="471" class="Symbol">(</a> <a id="473" href="Agda.Primitive.html#810" class="Primitive Operator">_⊔_</a> <a id="477" class="Symbol">;</a> <a id="479" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="484" class="Symbol">;</a> <a id="486" href="Agda.Primitive.html#597" class="Postulate">Level</a> <a id="492" class="Symbol">)</a> <a id="494" class="Keyword">renaming</a> <a id="503" class="Symbol">(</a> <a id="505" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="509" class="Symbol">to</a> <a id="512" class="Primitive">Type</a> <a id="517" class="Symbol">)</a>
<a id="519" class="Keyword">open</a> <a id="524" class="Keyword">import</a> <a id="531" href="Data.Product.html" class="Module">Data.Product</a>                <a id="559" class="Keyword">using</a> <a id="565" class="Symbol">(</a> <a id="567" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="571" class="Symbol">;</a> <a id="573" href="Data.Product.html#1167" class="Function Operator">_×_</a> <a id="577" class="Symbol">;</a> <a id="579" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="581" class="Symbol">)</a>
<a id="583" class="Keyword">open</a> <a id="588" class="Keyword">import</a> <a id="595" href="Function.Base.html" class="Module">Function.Base</a>               <a id="623" class="Keyword">using</a> <a id="629" class="Symbol">(</a> <a id="631" href="Function.Base.html#1031" class="Function Operator">_∘_</a> <a id="635" class="Symbol">)</a>
<a id="637" class="Keyword">open</a> <a id="642" class="Keyword">import</a> <a id="649" href="Function.Definitions.html" class="Module">Function.Definitions</a>        <a id="677" class="Keyword">using</a> <a id="683" class="Symbol">(</a> <a id="685" href="Function.Definitions.html#889" class="Function">Injective</a> <a id="695" class="Symbol">)</a>
<a id="697" class="Keyword">open</a> <a id="702" class="Keyword">import</a> <a id="709" href="Function.Bundles.html" class="Module">Function.Bundles</a>            <a id="737" class="Keyword">using</a> <a id="743" class="Symbol">(</a> <a id="745" href="Function.Bundles.html#8289" class="Function Operator">_↣_</a> <a id="749" class="Symbol">;</a> <a id="751" href="Function.Bundles.html#9178" class="Function">mk↣</a> <a id="755" class="Symbol">)</a>
<a id="757" class="Keyword">open</a> <a id="762" class="Keyword">import</a> <a id="769" href="Function.Construct.Identity.html" class="Module">Function.Construct.Identity</a> <a id="797" class="Keyword">using</a> <a id="803" class="Symbol">(</a> <a id="805" href="Function.Construct.Identity.html#3966" class="Function">id-↣</a> <a id="810" class="Symbol">)</a>
<a id="812" class="Keyword">open</a> <a id="817" class="Keyword">import</a> <a id="824" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
                                        <a id="902" class="Keyword">using</a> <a id="908" class="Symbol">(</a> <a id="910" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a> <a id="914" class="Symbol">;</a> <a id="916" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="921" class="Symbol">;</a> <a id="923" class="Keyword">module</a> <a id="930" href="Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">≡-Reasoning</a> <a id="942" class="Symbol">;</a> <a id="944" href="Relation.Binary.PropositionalEquality.Core.html#1461" class="Function">cong-app</a> <a id="953" class="Symbol">)</a>

<a id="956" class="Comment">-- Imports from agda-algebras</a>
<a id="986" class="Keyword">open</a> <a id="991" class="Keyword">import</a> <a id="998" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="1021" class="Keyword">using</a> <a id="1027" class="Symbol">(</a> <a id="1029" href="Overture.Preliminaries.html#4931" class="Function Operator">_⁻¹</a> <a id="1033" class="Symbol">;</a> <a id="1035" href="Overture.Preliminaries.html#9315" class="Function Operator">_≈_</a> <a id="1039" class="Symbol">;</a> <a id="1041" href="Overture.Preliminaries.html#5257" class="Function Operator">_∙_</a> <a id="1045" class="Symbol">)</a>

</pre>

We begin by defining an data type that represents the semantic concept of *inverse image* of a function.

<pre class="Agda">

<a id="1180" class="Keyword">private</a> <a id="1188" class="Keyword">variable</a> <a id="1197" href="Overture.Inverses.html#1197" class="Generalizable">α</a> <a id="1199" href="Overture.Inverses.html#1199" class="Generalizable">β</a> <a id="1201" href="Overture.Inverses.html#1201" class="Generalizable">γ</a> <a id="1203" class="Symbol">:</a> <a id="1205" href="Agda.Primitive.html#597" class="Postulate">Level</a>

<a id="1212" class="Keyword">module</a> <a id="1219" href="Overture.Inverses.html#1219" class="Module">_</a> <a id="1221" class="Symbol">{</a><a id="1222" href="Overture.Inverses.html#1222" class="Bound">A</a> <a id="1224" class="Symbol">:</a> <a id="1226" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="1231" href="Overture.Inverses.html#1197" class="Generalizable">α</a> <a id="1233" class="Symbol">}{</a><a id="1235" href="Overture.Inverses.html#1235" class="Bound">B</a> <a id="1237" class="Symbol">:</a> <a id="1239" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="1244" href="Overture.Inverses.html#1199" class="Generalizable">β</a> <a id="1246" class="Symbol">}</a> <a id="1248" class="Keyword">where</a>

 <a id="1256" class="Keyword">data</a> <a id="1261" href="Overture.Inverses.html#1261" class="Datatype Operator">Image_∋_</a> <a id="1270" class="Symbol">(</a><a id="1271" href="Overture.Inverses.html#1271" class="Bound">f</a> <a id="1273" class="Symbol">:</a> <a id="1275" href="Overture.Inverses.html#1222" class="Bound">A</a> <a id="1277" class="Symbol">→</a> <a id="1279" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="1280" class="Symbol">)</a> <a id="1282" class="Symbol">:</a> <a id="1284" href="Overture.Inverses.html#1235" class="Bound">B</a> <a id="1286" class="Symbol">→</a> <a id="1288" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="1293" class="Symbol">(</a><a id="1294" href="Overture.Inverses.html#1231" class="Bound">α</a> <a id="1296" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1298" href="Overture.Inverses.html#1244" class="Bound">β</a><a id="1299" class="Symbol">)</a> <a id="1301" class="Keyword">where</a>
  <a id="1309" href="Overture.Inverses.html#1309" class="InductiveConstructor">eq</a> <a id="1312" class="Symbol">:</a> <a id="1314" class="Symbol">{</a><a id="1315" href="Overture.Inverses.html#1315" class="Bound">b</a> <a id="1317" class="Symbol">:</a> <a id="1319" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="1320" class="Symbol">}</a> <a id="1322" class="Symbol">→</a> <a id="1324" class="Symbol">(</a><a id="1325" href="Overture.Inverses.html#1325" class="Bound">a</a> <a id="1327" class="Symbol">:</a> <a id="1329" href="Overture.Inverses.html#1222" class="Bound">A</a><a id="1330" class="Symbol">)</a> <a id="1332" class="Symbol">→</a> <a id="1334" href="Overture.Inverses.html#1315" class="Bound">b</a> <a id="1336" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1338" href="Overture.Inverses.html#1271" class="Bound">f</a> <a id="1340" href="Overture.Inverses.html#1325" class="Bound">a</a> <a id="1342" class="Symbol">→</a> <a id="1344" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="1350" href="Overture.Inverses.html#1271" class="Bound">f</a> <a id="1352" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="1354" href="Overture.Inverses.html#1315" class="Bound">b</a>

</pre>

An inhabitant of `Image f ∋ b` is a dependent pair `(a , p)`, where `a : A` and `p : b ≡ f a` is a proof that `f` maps `a` to `b`.  Since the proof that `b` belongs to the image of `f` is always accompanied by a witness `a : A`, we can actually *compute* a (pseudo)inverse of `f`. For convenience, we define this inverse function, which we call `Inv`, and which takes an arbitrary `b : B` and a (*witness*, *proof*)-pair, `(a , p) : Image f ∋ b`, and returns the witness `a`.

<pre class="Agda">

 <a id="1861" href="Overture.Inverses.html#1861" class="Function">Inv</a> <a id="1865" class="Symbol">:</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Overture.Inverses.html#1868" class="Bound">f</a> <a id="1870" class="Symbol">:</a> <a id="1872" href="Overture.Inverses.html#1222" class="Bound">A</a> <a id="1874" class="Symbol">→</a> <a id="1876" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="1877" class="Symbol">){</a><a id="1879" href="Overture.Inverses.html#1879" class="Bound">b</a> <a id="1881" class="Symbol">:</a> <a id="1883" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="1884" class="Symbol">}</a> <a id="1886" class="Symbol">→</a> <a id="1888" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="1894" href="Overture.Inverses.html#1868" class="Bound">f</a> <a id="1896" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="1898" href="Overture.Inverses.html#1879" class="Bound">b</a>  <a id="1901" class="Symbol">→</a>  <a id="1904" href="Overture.Inverses.html#1222" class="Bound">A</a>
 <a id="1907" href="Overture.Inverses.html#1861" class="Function">Inv</a> <a id="1911" href="Overture.Inverses.html#1911" class="Bound">f</a> <a id="1913" class="Symbol">(</a><a id="1914" href="Overture.Inverses.html#1309" class="InductiveConstructor">eq</a> <a id="1917" href="Overture.Inverses.html#1917" class="Bound">a</a> <a id="1919" class="Symbol">_)</a> <a id="1922" class="Symbol">=</a> <a id="1924" href="Overture.Inverses.html#1917" class="Bound">a</a>

</pre>

We can prove that `Inv f` is the *right-inverse* of `f`, as follows.

<pre class="Agda">

 <a id="2024" href="Overture.Inverses.html#2024" class="Function">InvIsInv</a> <a id="2033" class="Symbol">:</a> <a id="2035" class="Symbol">(</a><a id="2036" href="Overture.Inverses.html#2036" class="Bound">f</a> <a id="2038" class="Symbol">:</a> <a id="2040" href="Overture.Inverses.html#1222" class="Bound">A</a> <a id="2042" class="Symbol">→</a> <a id="2044" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="2045" class="Symbol">){</a><a id="2047" href="Overture.Inverses.html#2047" class="Bound">b</a> <a id="2049" class="Symbol">:</a> <a id="2051" href="Overture.Inverses.html#1235" class="Bound">B</a><a id="2052" class="Symbol">}(</a><a id="2054" href="Overture.Inverses.html#2054" class="Bound">q</a> <a id="2056" class="Symbol">:</a> <a id="2058" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="2064" href="Overture.Inverses.html#2036" class="Bound">f</a> <a id="2066" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="2068" href="Overture.Inverses.html#2047" class="Bound">b</a><a id="2069" class="Symbol">)</a> <a id="2071" class="Symbol">→</a> <a id="2073" href="Overture.Inverses.html#2036" class="Bound">f</a><a id="2074" class="Symbol">(</a><a id="2075" href="Overture.Inverses.html#1861" class="Function">Inv</a> <a id="2079" href="Overture.Inverses.html#2036" class="Bound">f</a> <a id="2081" href="Overture.Inverses.html#2054" class="Bound">q</a><a id="2082" class="Symbol">)</a> <a id="2084" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2086" href="Overture.Inverses.html#2047" class="Bound">b</a>
 <a id="2089" href="Overture.Inverses.html#2024" class="Function">InvIsInv</a> <a id="2098" href="Overture.Inverses.html#2098" class="Bound">f</a> <a id="2100" class="Symbol">(</a><a id="2101" href="Overture.Inverses.html#1309" class="InductiveConstructor">eq</a> <a id="2104" class="Symbol">_</a> <a id="2106" href="Overture.Inverses.html#2106" class="Bound">p</a><a id="2107" class="Symbol">)</a> <a id="2109" class="Symbol">=</a> <a id="2111" href="Overture.Inverses.html#2106" class="Bound">p</a> <a id="2113" href="Overture.Preliminaries.html#4931" class="Function Operator">⁻¹</a>

</pre>


#### <a id="injective-functions">Injective functions</a>

We say that a function `f : A → B` is *injective* (or *monic*) if it does not map two distinct elements of the domain to the same point in the codomain. The following type manifests this property.

<pre class="Agda">

<a id="2400" class="Keyword">module</a> <a id="2407" href="Overture.Inverses.html#2407" class="Module">_</a> <a id="2409" class="Symbol">{</a><a id="2410" href="Overture.Inverses.html#2410" class="Bound">A</a> <a id="2412" class="Symbol">:</a> <a id="2414" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2419" href="Overture.Inverses.html#1197" class="Generalizable">α</a><a id="2420" class="Symbol">}{</a><a id="2422" href="Overture.Inverses.html#2422" class="Bound">B</a> <a id="2424" class="Symbol">:</a> <a id="2426" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2431" href="Overture.Inverses.html#1199" class="Generalizable">β</a><a id="2432" class="Symbol">}</a> <a id="2434" class="Keyword">where</a>

 <a id="2442" href="Overture.Inverses.html#2442" class="Function">IsInjective</a> <a id="2454" class="Symbol">:</a> <a id="2456" class="Symbol">(</a><a id="2457" href="Overture.Inverses.html#2410" class="Bound">A</a> <a id="2459" class="Symbol">→</a> <a id="2461" href="Overture.Inverses.html#2422" class="Bound">B</a><a id="2462" class="Symbol">)</a> <a id="2464" class="Symbol">→</a> <a id="2466" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2471" class="Symbol">(</a><a id="2472" href="Overture.Inverses.html#2419" class="Bound">α</a> <a id="2474" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2476" href="Overture.Inverses.html#2431" class="Bound">β</a><a id="2477" class="Symbol">)</a>
 <a id="2480" href="Overture.Inverses.html#2442" class="Function">IsInjective</a> <a id="2492" href="Overture.Inverses.html#2492" class="Bound">f</a> <a id="2494" class="Symbol">=</a> <a id="2496" href="Function.Definitions.html#889" class="Function">Injective</a> <a id="2506" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a> <a id="2510" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a> <a id="2514" href="Overture.Inverses.html#2492" class="Bound">f</a>

</pre>

Before moving on to discuss surjective functions, let us prove (the obvious facts) that the identity map is injective and that the composition of injectives is injective.

<pre class="Agda">

<a id="id-is-injective"></a><a id="2715" href="Overture.Inverses.html#2715" class="Function">id-is-injective</a> <a id="2731" class="Symbol">:</a> <a id="2733" class="Symbol">{</a><a id="2734" href="Overture.Inverses.html#2734" class="Bound">A</a> <a id="2736" class="Symbol">:</a> <a id="2738" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2743" href="Overture.Inverses.html#1197" class="Generalizable">α</a><a id="2744" class="Symbol">}</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="Overture.Inverses.html#2734" class="Bound">A</a> <a id="2750" href="Function.Bundles.html#8289" class="Function Operator">↣</a> <a id="2752" href="Overture.Inverses.html#2734" class="Bound">A</a>
<a id="2754" href="Overture.Inverses.html#2715" class="Function">id-is-injective</a> <a id="2770" class="Symbol">{</a><a id="2771" class="Argument">A</a> <a id="2773" class="Symbol">=</a> <a id="2775" href="Overture.Inverses.html#2775" class="Bound">A</a><a id="2776" class="Symbol">}</a> <a id="2778" class="Symbol">=</a> <a id="2780" href="Function.Construct.Identity.html#3966" class="Function">id-↣</a> <a id="2785" href="Overture.Inverses.html#2775" class="Bound">A</a>

<a id="∘-injective"></a><a id="2788" href="Overture.Inverses.html#2788" class="Function">∘-injective</a> <a id="2800" class="Symbol">:</a> <a id="2802" class="Symbol">{</a><a id="2803" href="Overture.Inverses.html#2803" class="Bound">A</a> <a id="2805" class="Symbol">:</a> <a id="2807" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2812" href="Overture.Inverses.html#1197" class="Generalizable">α</a><a id="2813" class="Symbol">}{</a><a id="2815" href="Overture.Inverses.html#2815" class="Bound">B</a> <a id="2817" class="Symbol">:</a> <a id="2819" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2824" href="Overture.Inverses.html#1199" class="Generalizable">β</a><a id="2825" class="Symbol">}{</a><a id="2827" href="Overture.Inverses.html#2827" class="Bound">C</a> <a id="2829" class="Symbol">:</a> <a id="2831" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="2836" href="Overture.Inverses.html#1201" class="Generalizable">γ</a><a id="2837" class="Symbol">}{</a><a id="2839" href="Overture.Inverses.html#2839" class="Bound">f</a> <a id="2841" class="Symbol">:</a> <a id="2843" href="Overture.Inverses.html#2803" class="Bound">A</a> <a id="2845" class="Symbol">→</a> <a id="2847" href="Overture.Inverses.html#2815" class="Bound">B</a><a id="2848" class="Symbol">}{</a><a id="2850" href="Overture.Inverses.html#2850" class="Bound">g</a> <a id="2852" class="Symbol">:</a> <a id="2854" href="Overture.Inverses.html#2815" class="Bound">B</a> <a id="2856" class="Symbol">→</a> <a id="2858" href="Overture.Inverses.html#2827" class="Bound">C</a><a id="2859" class="Symbol">}</a>
 <a id="2862" class="Symbol">→</a>            <a id="2875" href="Overture.Inverses.html#2442" class="Function">IsInjective</a> <a id="2887" href="Overture.Inverses.html#2839" class="Bound">f</a> <a id="2889" class="Symbol">→</a> <a id="2891" href="Overture.Inverses.html#2442" class="Function">IsInjective</a> <a id="2903" href="Overture.Inverses.html#2850" class="Bound">g</a> <a id="2905" class="Symbol">→</a> <a id="2907" href="Overture.Inverses.html#2442" class="Function">IsInjective</a> <a id="2919" class="Symbol">(</a><a id="2920" href="Overture.Inverses.html#2850" class="Bound">g</a> <a id="2922" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2924" href="Overture.Inverses.html#2839" class="Bound">f</a><a id="2925" class="Symbol">)</a>
<a id="2927" href="Overture.Inverses.html#2788" class="Function">∘-injective</a> <a id="2939" href="Overture.Inverses.html#2939" class="Bound">finj</a> <a id="2944" href="Overture.Inverses.html#2944" class="Bound">ginj</a> <a id="2949" class="Symbol">=</a> <a id="2951" class="Symbol">λ</a> <a id="2953" href="Overture.Inverses.html#2953" class="Bound">z</a> <a id="2955" class="Symbol">→</a> <a id="2957" href="Overture.Inverses.html#2939" class="Bound">finj</a> <a id="2962" class="Symbol">(</a><a id="2963" href="Overture.Inverses.html#2944" class="Bound">ginj</a> <a id="2968" href="Overture.Inverses.html#2953" class="Bound">z</a><a id="2969" class="Symbol">)</a>

</pre>


#### <a id="epics">Surjective functions</a>

A *surjective function* from `A` to `B` is a function `f : A → B` such that for all `b : B` there exists `a : A` such that `f a ≡ b`.  In other words, the range and codomain of `f` agree.  The following types manifest this notion.

<pre class="Agda">

<a id="3276" class="Keyword">module</a> <a id="3283" href="Overture.Inverses.html#3283" class="Module">_</a> <a id="3285" class="Symbol">{</a><a id="3286" href="Overture.Inverses.html#3286" class="Bound">A</a> <a id="3288" class="Symbol">:</a> <a id="3290" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3295" href="Overture.Inverses.html#1197" class="Generalizable">α</a><a id="3296" class="Symbol">}{</a><a id="3298" href="Overture.Inverses.html#3298" class="Bound">B</a> <a id="3300" class="Symbol">:</a> <a id="3302" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3307" href="Overture.Inverses.html#1199" class="Generalizable">β</a><a id="3308" class="Symbol">}</a> <a id="3310" class="Keyword">where</a>
 <a id="3317" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="3330" class="Symbol">:</a> <a id="3332" class="Symbol">(</a><a id="3333" href="Overture.Inverses.html#3286" class="Bound">A</a> <a id="3335" class="Symbol">→</a> <a id="3337" href="Overture.Inverses.html#3298" class="Bound">B</a><a id="3338" class="Symbol">)</a> <a id="3340" class="Symbol">→</a>  <a id="3343" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3348" class="Symbol">(</a><a id="3349" href="Overture.Inverses.html#3295" class="Bound">α</a> <a id="3351" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3353" href="Overture.Inverses.html#3307" class="Bound">β</a><a id="3354" class="Symbol">)</a>
 <a id="3357" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="3370" href="Overture.Inverses.html#3370" class="Bound">f</a> <a id="3372" class="Symbol">=</a> <a id="3374" class="Symbol">∀</a> <a id="3376" href="Overture.Inverses.html#3376" class="Bound">y</a> <a id="3378" class="Symbol">→</a> <a id="3380" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="3386" href="Overture.Inverses.html#3370" class="Bound">f</a> <a id="3388" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="3390" href="Overture.Inverses.html#3376" class="Bound">y</a>

 <a id="3394" href="Overture.Inverses.html#3394" class="Function">Surjective</a> <a id="3405" class="Symbol">:</a> <a id="3407" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3412" class="Symbol">(</a><a id="3413" href="Overture.Inverses.html#3295" class="Bound">α</a> <a id="3415" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3417" href="Overture.Inverses.html#3307" class="Bound">β</a><a id="3418" class="Symbol">)</a>
 <a id="3421" href="Overture.Inverses.html#3394" class="Function">Surjective</a> <a id="3432" class="Symbol">=</a> <a id="3434" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="3436" class="Symbol">(</a><a id="3437" href="Overture.Inverses.html#3286" class="Bound">A</a> <a id="3439" class="Symbol">→</a> <a id="3441" href="Overture.Inverses.html#3298" class="Bound">B</a><a id="3442" class="Symbol">)</a> <a id="3444" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a>

</pre>

With the next definition, we can represent a *right-inverse* of a surjective function.

<pre class="Agda">

 <a id="3573" href="Overture.Inverses.html#3573" class="Function">SurjInv</a> <a id="3581" class="Symbol">:</a> <a id="3583" class="Symbol">(</a><a id="3584" href="Overture.Inverses.html#3584" class="Bound">f</a> <a id="3586" class="Symbol">:</a> <a id="3588" href="Overture.Inverses.html#3286" class="Bound">A</a> <a id="3590" class="Symbol">→</a> <a id="3592" href="Overture.Inverses.html#3298" class="Bound">B</a><a id="3593" class="Symbol">)</a> <a id="3595" class="Symbol">→</a> <a id="3597" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="3610" href="Overture.Inverses.html#3584" class="Bound">f</a> <a id="3612" class="Symbol">→</a> <a id="3614" href="Overture.Inverses.html#3298" class="Bound">B</a> <a id="3616" class="Symbol">→</a> <a id="3618" href="Overture.Inverses.html#3286" class="Bound">A</a>
 <a id="3621" href="Overture.Inverses.html#3573" class="Function">SurjInv</a> <a id="3629" href="Overture.Inverses.html#3629" class="Bound">f</a> <a id="3631" href="Overture.Inverses.html#3631" class="Bound">fE</a> <a id="3634" href="Overture.Inverses.html#3634" class="Bound">b</a> <a id="3636" class="Symbol">=</a> <a id="3638" href="Overture.Inverses.html#1861" class="Function">Inv</a> <a id="3642" href="Overture.Inverses.html#3629" class="Bound">f</a> <a id="3644" class="Symbol">(</a><a id="3645" href="Overture.Inverses.html#3631" class="Bound">fE</a> <a id="3648" href="Overture.Inverses.html#3634" class="Bound">b</a><a id="3649" class="Symbol">)</a>

</pre>

Thus, a right-inverse of `f` is obtained by applying `SurjInv` to `f` and a proof of `IsSurjective f`.  Next we prove that this does indeed give the right-inverse.

<pre class="Agda">

<a id="3843" class="Keyword">module</a> <a id="3850" href="Overture.Inverses.html#3850" class="Module">_</a> <a id="3852" class="Symbol">{</a><a id="3853" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="3855" class="Symbol">:</a> <a id="3857" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3862" href="Overture.Inverses.html#1197" class="Generalizable">α</a><a id="3863" class="Symbol">}{</a><a id="3865" href="Overture.Inverses.html#3865" class="Bound">B</a> <a id="3867" class="Symbol">:</a> <a id="3869" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="3874" href="Overture.Inverses.html#1199" class="Generalizable">β</a><a id="3875" class="Symbol">}</a> <a id="3877" class="Keyword">where</a>

 <a id="3885" href="Overture.Inverses.html#3885" class="Function">SurjInvIsRightInv</a> <a id="3903" class="Symbol">:</a> <a id="3905" class="Symbol">(</a><a id="3906" href="Overture.Inverses.html#3906" class="Bound">f</a> <a id="3908" class="Symbol">:</a> <a id="3910" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="3912" class="Symbol">→</a> <a id="3914" href="Overture.Inverses.html#3865" class="Bound">B</a><a id="3915" class="Symbol">)(</a><a id="3917" href="Overture.Inverses.html#3917" class="Bound">fE</a> <a id="3920" class="Symbol">:</a> <a id="3922" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="3935" href="Overture.Inverses.html#3906" class="Bound">f</a><a id="3936" class="Symbol">)</a> <a id="3938" class="Symbol">→</a> <a id="3940" class="Symbol">∀</a> <a id="3942" href="Overture.Inverses.html#3942" class="Bound">b</a> <a id="3944" class="Symbol">→</a> <a id="3946" href="Overture.Inverses.html#3906" class="Bound">f</a> <a id="3948" class="Symbol">((</a><a id="3950" href="Overture.Inverses.html#3573" class="Function">SurjInv</a> <a id="3958" href="Overture.Inverses.html#3906" class="Bound">f</a> <a id="3960" href="Overture.Inverses.html#3917" class="Bound">fE</a><a id="3962" class="Symbol">)</a> <a id="3964" href="Overture.Inverses.html#3942" class="Bound">b</a><a id="3965" class="Symbol">)</a> <a id="3967" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3969" href="Overture.Inverses.html#3942" class="Bound">b</a>
 <a id="3972" href="Overture.Inverses.html#3885" class="Function">SurjInvIsRightInv</a> <a id="3990" href="Overture.Inverses.html#3990" class="Bound">f</a> <a id="3992" href="Overture.Inverses.html#3992" class="Bound">fE</a> <a id="3995" href="Overture.Inverses.html#3995" class="Bound">b</a> <a id="3997" class="Symbol">=</a> <a id="3999" href="Overture.Inverses.html#2024" class="Function">InvIsInv</a> <a id="4008" href="Overture.Inverses.html#3990" class="Bound">f</a> <a id="4010" class="Symbol">(</a><a id="4011" href="Overture.Inverses.html#3992" class="Bound">fE</a> <a id="4014" href="Overture.Inverses.html#3995" class="Bound">b</a><a id="4015" class="Symbol">)</a>

 <a id="4019" class="Keyword">open</a> <a id="4024" href="Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">≡-Reasoning</a>

 <a id="4038" class="Comment">-- composition law for epics</a>
 <a id="4068" href="Overture.Inverses.html#4068" class="Function">epic-factor</a> <a id="4080" class="Symbol">:</a> <a id="4082" class="Symbol">{</a><a id="4083" href="Overture.Inverses.html#4083" class="Bound">C</a> <a id="4085" class="Symbol">:</a> <a id="4087" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="4092" href="Overture.Inverses.html#1201" class="Generalizable">γ</a><a id="4093" class="Symbol">}(</a><a id="4095" href="Overture.Inverses.html#4095" class="Bound">f</a> <a id="4097" class="Symbol">:</a> <a id="4099" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="4101" class="Symbol">→</a> <a id="4103" href="Overture.Inverses.html#3865" class="Bound">B</a><a id="4104" class="Symbol">)(</a><a id="4106" href="Overture.Inverses.html#4106" class="Bound">g</a> <a id="4108" class="Symbol">:</a> <a id="4110" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="4112" class="Symbol">→</a> <a id="4114" href="Overture.Inverses.html#4083" class="Bound">C</a><a id="4115" class="Symbol">)(</a><a id="4117" href="Overture.Inverses.html#4117" class="Bound">h</a> <a id="4119" class="Symbol">:</a> <a id="4121" href="Overture.Inverses.html#4083" class="Bound">C</a> <a id="4123" class="Symbol">→</a> <a id="4125" href="Overture.Inverses.html#3865" class="Bound">B</a><a id="4126" class="Symbol">)</a>
  <a id="4130" class="Symbol">→</a>            <a id="4143" href="Overture.Inverses.html#4095" class="Bound">f</a> <a id="4145" href="Overture.Preliminaries.html#9315" class="Function Operator">≈</a> <a id="4147" href="Overture.Inverses.html#4117" class="Bound">h</a> <a id="4149" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4151" href="Overture.Inverses.html#4106" class="Bound">g</a> <a id="4153" class="Symbol">→</a> <a id="4155" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="4168" href="Overture.Inverses.html#4095" class="Bound">f</a> <a id="4170" class="Symbol">→</a> <a id="4172" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="4185" href="Overture.Inverses.html#4117" class="Bound">h</a>

 <a id="4189" href="Overture.Inverses.html#4068" class="Function">epic-factor</a> <a id="4201" href="Overture.Inverses.html#4201" class="Bound">f</a> <a id="4203" href="Overture.Inverses.html#4203" class="Bound">g</a> <a id="4205" href="Overture.Inverses.html#4205" class="Bound">h</a> <a id="4207" href="Overture.Inverses.html#4207" class="Bound">compId</a> <a id="4214" href="Overture.Inverses.html#4214" class="Bound">fe</a> <a id="4217" href="Overture.Inverses.html#4217" class="Bound">y</a> <a id="4219" class="Symbol">=</a> <a id="4221" href="Overture.Inverses.html#4392" class="Function">Goal</a>
  <a id="4228" class="Keyword">where</a>
   <a id="4237" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4242" class="Symbol">:</a> <a id="4244" href="Overture.Inverses.html#3865" class="Bound">B</a> <a id="4246" class="Symbol">→</a> <a id="4248" href="Overture.Inverses.html#3853" class="Bound">A</a>
   <a id="4253" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4258" class="Symbol">=</a> <a id="4260" href="Overture.Inverses.html#3573" class="Function">SurjInv</a> <a id="4268" href="Overture.Inverses.html#4201" class="Bound">f</a> <a id="4270" href="Overture.Inverses.html#4214" class="Bound">fe</a>

   <a id="4277" href="Overture.Inverses.html#4277" class="Function">ζ</a> <a id="4279" class="Symbol">:</a> <a id="4281" href="Overture.Inverses.html#4217" class="Bound">y</a> <a id="4283" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4285" href="Overture.Inverses.html#4201" class="Bound">f</a> <a id="4287" class="Symbol">(</a><a id="4288" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4293" href="Overture.Inverses.html#4217" class="Bound">y</a><a id="4294" class="Symbol">)</a>
   <a id="4299" href="Overture.Inverses.html#4277" class="Function">ζ</a> <a id="4301" class="Symbol">=</a> <a id="4303" class="Symbol">(</a><a id="4304" href="Overture.Inverses.html#3885" class="Function">SurjInvIsRightInv</a> <a id="4322" href="Overture.Inverses.html#4201" class="Bound">f</a> <a id="4324" href="Overture.Inverses.html#4214" class="Bound">fe</a> <a id="4327" href="Overture.Inverses.html#4217" class="Bound">y</a><a id="4328" class="Symbol">)</a><a id="4329" href="Overture.Preliminaries.html#4931" class="Function Operator">⁻¹</a>

   <a id="4336" href="Overture.Inverses.html#4336" class="Function">η</a> <a id="4338" class="Symbol">:</a> <a id="4340" href="Overture.Inverses.html#4217" class="Bound">y</a> <a id="4342" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4344" class="Symbol">(</a><a id="4345" href="Overture.Inverses.html#4205" class="Bound">h</a> <a id="4347" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4349" href="Overture.Inverses.html#4203" class="Bound">g</a><a id="4350" class="Symbol">)</a> <a id="4352" class="Symbol">(</a><a id="4353" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4358" href="Overture.Inverses.html#4217" class="Bound">y</a><a id="4359" class="Symbol">)</a>
   <a id="4364" href="Overture.Inverses.html#4336" class="Function">η</a> <a id="4366" class="Symbol">=</a> <a id="4368" href="Overture.Inverses.html#4277" class="Function">ζ</a> <a id="4370" href="Overture.Preliminaries.html#5257" class="Function Operator">∙</a> <a id="4372" href="Overture.Inverses.html#4207" class="Bound">compId</a> <a id="4379" class="Symbol">(</a><a id="4380" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4385" href="Overture.Inverses.html#4217" class="Bound">y</a><a id="4386" class="Symbol">)</a>

   <a id="4392" href="Overture.Inverses.html#4392" class="Function">Goal</a> <a id="4397" class="Symbol">:</a> <a id="4399" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="4405" href="Overture.Inverses.html#4205" class="Bound">h</a> <a id="4407" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="4409" href="Overture.Inverses.html#4217" class="Bound">y</a>
   <a id="4414" href="Overture.Inverses.html#4392" class="Function">Goal</a> <a id="4419" class="Symbol">=</a> <a id="4421" href="Overture.Inverses.html#1309" class="InductiveConstructor">eq</a> <a id="4424" class="Symbol">(</a><a id="4425" href="Overture.Inverses.html#4203" class="Bound">g</a> <a id="4427" class="Symbol">(</a><a id="4428" href="Overture.Inverses.html#4237" class="Function">finv</a> <a id="4433" href="Overture.Inverses.html#4217" class="Bound">y</a><a id="4434" class="Symbol">))</a> <a id="4437" href="Overture.Inverses.html#4336" class="Function">η</a>

 <a id="4441" href="Overture.Inverses.html#4441" class="Function">epic-factor-intensional</a> <a id="4465" class="Symbol">:</a> <a id="4467" class="Symbol">{</a><a id="4468" href="Overture.Inverses.html#4468" class="Bound">C</a> <a id="4470" class="Symbol">:</a> <a id="4472" href="Overture.Inverses.html#512" class="Primitive">Type</a> <a id="4477" href="Overture.Inverses.html#1201" class="Generalizable">γ</a><a id="4478" class="Symbol">}(</a><a id="4480" href="Overture.Inverses.html#4480" class="Bound">f</a> <a id="4482" class="Symbol">:</a> <a id="4484" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="4486" class="Symbol">→</a> <a id="4488" href="Overture.Inverses.html#3865" class="Bound">B</a><a id="4489" class="Symbol">)(</a><a id="4491" href="Overture.Inverses.html#4491" class="Bound">g</a> <a id="4493" class="Symbol">:</a> <a id="4495" href="Overture.Inverses.html#3853" class="Bound">A</a> <a id="4497" class="Symbol">→</a> <a id="4499" href="Overture.Inverses.html#4468" class="Bound">C</a><a id="4500" class="Symbol">)(</a><a id="4502" href="Overture.Inverses.html#4502" class="Bound">h</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="Overture.Inverses.html#4468" class="Bound">C</a> <a id="4508" class="Symbol">→</a> <a id="4510" href="Overture.Inverses.html#3865" class="Bound">B</a><a id="4511" class="Symbol">)</a>
  <a id="4515" class="Symbol">→</a>                        <a id="4540" href="Overture.Inverses.html#4480" class="Bound">f</a> <a id="4542" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4544" href="Overture.Inverses.html#4502" class="Bound">h</a> <a id="4546" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4548" href="Overture.Inverses.html#4491" class="Bound">g</a> <a id="4550" class="Symbol">→</a> <a id="4552" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="4565" href="Overture.Inverses.html#4480" class="Bound">f</a> <a id="4567" class="Symbol">→</a> <a id="4569" href="Overture.Inverses.html#3317" class="Function">IsSurjective</a> <a id="4582" href="Overture.Inverses.html#4502" class="Bound">h</a>

 <a id="4586" href="Overture.Inverses.html#4441" class="Function">epic-factor-intensional</a> <a id="4610" href="Overture.Inverses.html#4610" class="Bound">f</a> <a id="4612" href="Overture.Inverses.html#4612" class="Bound">g</a> <a id="4614" href="Overture.Inverses.html#4614" class="Bound">h</a> <a id="4616" href="Overture.Inverses.html#4616" class="Bound">compId</a> <a id="4623" href="Overture.Inverses.html#4623" class="Bound">fe</a> <a id="4626" href="Overture.Inverses.html#4626" class="Bound">y</a> <a id="4628" class="Symbol">=</a> <a id="4630" href="Overture.Inverses.html#4812" class="Function">Goal</a>
  <a id="4637" class="Keyword">where</a>
   <a id="4646" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4651" class="Symbol">:</a> <a id="4653" href="Overture.Inverses.html#3865" class="Bound">B</a> <a id="4655" class="Symbol">→</a> <a id="4657" href="Overture.Inverses.html#3853" class="Bound">A</a>
   <a id="4662" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4667" class="Symbol">=</a> <a id="4669" href="Overture.Inverses.html#3573" class="Function">SurjInv</a> <a id="4677" href="Overture.Inverses.html#4610" class="Bound">f</a> <a id="4679" href="Overture.Inverses.html#4623" class="Bound">fe</a>

   <a id="4686" href="Overture.Inverses.html#4686" class="Function">ζ</a> <a id="4688" class="Symbol">:</a> <a id="4690" href="Overture.Inverses.html#4610" class="Bound">f</a> <a id="4692" class="Symbol">(</a><a id="4693" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4698" href="Overture.Inverses.html#4626" class="Bound">y</a><a id="4699" class="Symbol">)</a> <a id="4701" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4703" href="Overture.Inverses.html#4626" class="Bound">y</a>
   <a id="4708" href="Overture.Inverses.html#4686" class="Function">ζ</a> <a id="4710" class="Symbol">=</a> <a id="4712" href="Overture.Inverses.html#3885" class="Function">SurjInvIsRightInv</a> <a id="4730" href="Overture.Inverses.html#4610" class="Bound">f</a> <a id="4732" href="Overture.Inverses.html#4623" class="Bound">fe</a> <a id="4735" href="Overture.Inverses.html#4626" class="Bound">y</a>

   <a id="4741" href="Overture.Inverses.html#4741" class="Function">η</a> <a id="4743" class="Symbol">:</a> <a id="4745" class="Symbol">(</a><a id="4746" href="Overture.Inverses.html#4614" class="Bound">h</a> <a id="4748" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4750" href="Overture.Inverses.html#4612" class="Bound">g</a><a id="4751" class="Symbol">)</a> <a id="4753" class="Symbol">(</a><a id="4754" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4759" href="Overture.Inverses.html#4626" class="Bound">y</a><a id="4760" class="Symbol">)</a> <a id="4762" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4764" href="Overture.Inverses.html#4626" class="Bound">y</a>
   <a id="4769" href="Overture.Inverses.html#4741" class="Function">η</a> <a id="4771" class="Symbol">=</a> <a id="4773" class="Symbol">(</a><a id="4774" href="Relation.Binary.PropositionalEquality.Core.html#1461" class="Function">cong-app</a> <a id="4783" class="Symbol">(</a><a id="4784" href="Overture.Inverses.html#4616" class="Bound">compId</a> <a id="4791" href="Overture.Preliminaries.html#4931" class="Function Operator">⁻¹</a><a id="4793" class="Symbol">)(</a><a id="4795" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4800" href="Overture.Inverses.html#4626" class="Bound">y</a><a id="4801" class="Symbol">))</a> <a id="4804" href="Overture.Preliminaries.html#5257" class="Function Operator">∙</a> <a id="4806" href="Overture.Inverses.html#4686" class="Function">ζ</a>

   <a id="4812" href="Overture.Inverses.html#4812" class="Function">Goal</a> <a id="4817" class="Symbol">:</a> <a id="4819" href="Overture.Inverses.html#1261" class="Datatype Operator">Image</a> <a id="4825" href="Overture.Inverses.html#4614" class="Bound">h</a> <a id="4827" href="Overture.Inverses.html#1261" class="Datatype Operator">∋</a> <a id="4829" href="Overture.Inverses.html#4626" class="Bound">y</a>
   <a id="4834" href="Overture.Inverses.html#4812" class="Function">Goal</a> <a id="4839" class="Symbol">=</a> <a id="4841" href="Overture.Inverses.html#1309" class="InductiveConstructor">eq</a> <a id="4844" class="Symbol">(</a><a id="4845" href="Overture.Inverses.html#4612" class="Bound">g</a> <a id="4847" class="Symbol">(</a><a id="4848" href="Overture.Inverses.html#4646" class="Function">finv</a> <a id="4853" href="Overture.Inverses.html#4626" class="Bound">y</a><a id="4854" class="Symbol">))</a> <a id="4857" class="Symbol">(</a><a id="4858" href="Overture.Inverses.html#4741" class="Function">η</a> <a id="4860" href="Overture.Preliminaries.html#4931" class="Function Operator">⁻¹</a><a id="4862" class="Symbol">)</a>

</pre>


--------------------------------------

[← Overture.Preliminaries](Overture.Preliminaries.html)
<span style="float:right;">[Overture.Transformers →](Overture.Transformers.html)</span>


{% include UALib.Links.md %}

[agda-algebras development team]: https://github.com/ualib/agda-algebras#the-agda-algebras-development-team


